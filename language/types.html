
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Types and Casting &#8212; OpenQASM Live Specification  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Gates" href="gates.html" />
    <link rel="prev" title="Comments" href="comments.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="types-and-casting">
<h1>Types and Casting<a class="headerlink" href="#types-and-casting" title="Permalink to this headline">¶</a></h1>
<section id="generalities">
<h2>Generalities<a class="headerlink" href="#generalities" title="Permalink to this headline">¶</a></h2>
<p>Variable identifiers must begin with a letter [A-Za-z], an underscore or an element from the Unicode character categories
Lu/Ll/Lt/Lm/Lo/Nl <span id="id1">[<a class="reference internal" href="../index.html#id51" title="Unicode Character Categories. URL: http://www.fileformat.info/info/unicode/category/index.htm (visited on 2020-10-23).">noa</a>]</span>. The set of permissible
continuation characters consists of all members of the aforementioned character
sets with the addition of decimal numerals [0-9]. Variable identifiers may not
override a reserved identifier.</p>
<p>In addition to being assigned values within a program, all of the classical
types can be initialized on declaration. Any classical variable or Boolean that is not explicitly
initialized is undefined. Classical types can be mutually cast to one another using the typename.</p>
<p>Declaration and initialization must be done one variable at a time for both quantum and classical
types. Comma seperated declaration/initialization (<code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z</span></code>) is NOT allowed for any type. For
example, to declare a set of qubits one must do</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span><span class="w"> </span><span class="n">q0</span><span class="p">;</span><span class="w"></span>
<span class="n">qubit</span><span class="w"> </span><span class="n">q1</span><span class="p">;</span><span class="w"></span>
<span class="n">qubit</span><span class="w"> </span><span class="n">q2</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>and to declare a set of classical variables</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.5</span><span class="p">;</span><span class="w"></span>
<span class="n">bit</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">my_bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>We use the notation <code class="docutils literal notranslate"><span class="pre">s:m:f</span></code> to denote the width and precision of fixed point numbers,
where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the number of sign bits, <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of integer bits, and <code class="docutils literal notranslate"><span class="pre">f</span></code> is the
number of fractional bits. It is necessary to specify low-level
classical representations since OpenQASM operates at the intersection of
gates/analog control and digital feedback and we need to be able to
explicitly transform types to cross these boundaries. Classical types
are scoped to the braces within which they are declared.</p>
</section>
<section id="quantum-types">
<h2>Quantum types<a class="headerlink" href="#quantum-types" title="Permalink to this headline">¶</a></h2>
<section id="qubits">
<h3>Qubits<a class="headerlink" href="#qubits" title="Permalink to this headline">¶</a></h3>
<p>There is a quantum bit (<code class="docutils literal notranslate"><span class="pre">qubit</span></code>) type that is interpreted as a reference to a
two-level subsystem of a quantum state. The statement <code class="docutils literal notranslate"><span class="pre">qubit</span> <span class="pre">name;</span></code>
declares a reference to a quantum bit. These qubits are referred
to as “virtual qubits” (in distinction to “physical qubits” on
actual hardware; see below). The statement <code class="docutils literal notranslate"><span class="pre">qubit[size]</span> <span class="pre">name;</span></code>
declares a quantum register with <code class="docutils literal notranslate"><span class="pre">size</span></code> qubits.
Sizes must always be constant positive integers. The label <code class="docutils literal notranslate"><span class="pre">name[j]</span></code>
refers to a qubit of this register, where
<span class="math notranslate nohighlight">\(j\in \{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}\)</span> is an integer.
Quantum registers are static arrays of qubits
that cannot be dynamically resized.</p>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">qreg</span></code> is included
for backwards compatibility and will be removed in the future.</p>
<p>Qubits are initially in an undefined state. A quantum <code class="docutils literal notranslate"><span class="pre">reset</span></code> operation is one
way to initialize qubit states.</p>
<p>All qubits are global variables.
Qubits cannot be declared within gates or subroutines. This simplifies OpenQASM
significantly since there is no need for quantum memory management.
However, it also means that users or compiler have to explicitly manage
the quantum memory.</p>
</section>
<section id="physical-qubits">
<h3>Physical Qubits<a class="headerlink" href="#physical-qubits" title="Permalink to this headline">¶</a></h3>
<p>While program qubits can be named, hardware qubits are referenced only
by the syntax <code class="docutils literal notranslate"><span class="pre">$[NUM]</span></code>. For an <code class="docutils literal notranslate"><span class="pre">n</span></code> qubit system, we have physical qubit
references given by <code class="docutils literal notranslate"><span class="pre">$0</span></code>, <code class="docutils literal notranslate"><span class="pre">$1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">$n-1</span></code>. These qubit types are
used in lower parts of the compilation stack when emitting physical
circuits. Physical qubits must not be declared and they are, as all the qubits, global variables.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a qubit</span>
<span class="n">qubit</span><span class="w"> </span><span class="n">gamma</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Declare a qubit with a Unicode name</span>
<span class="n">qubit</span><span class="w"> </span><span class="err">γ</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Declare a qubit register with 20 qubits</span>
<span class="n">qubit</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="n">qubit_array</span><span class="p">;</span><span class="w"></span>
<span class="c1">// CNOT gate between physical qubits 0 and 1</span>
<span class="n">CX</span><span class="w"> </span><span class="n">$0</span><span class="p">,</span><span class="w"> </span><span class="n">$1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="classical-types">
<h2>Classical types<a class="headerlink" href="#classical-types" title="Permalink to this headline">¶</a></h2>
<section id="classical-bits-and-registers">
<h3>Classical bits and registers<a class="headerlink" href="#classical-bits-and-registers" title="Permalink to this headline">¶</a></h3>
<p>There is a classical bit type that takes values 0 or 1. Classical
registers are static arrays of bits. The classical registers model part
of the controller state that is exposed within the OpenQASM program. The
statement <code class="docutils literal notranslate"><span class="pre">bit</span> <span class="pre">name;</span></code> declares a classical bit, and or <code class="docutils literal notranslate"><span class="pre">bit[size]</span> <span class="pre">name;</span></code> declares a register of
<code class="docutils literal notranslate"><span class="pre">size</span></code> bits. The label <code class="docutils literal notranslate"><span class="pre">name[j]</span></code> refers to a bit of this register, where <span class="math notranslate nohighlight">\(j\in
\{0,1,\dots,\mathrm{size}(\mathrm{name})-1\}\)</span> is an integer.</p>
<p>Bit registers may also be declared as <code class="docutils literal notranslate"><span class="pre">creg</span> <span class="pre">name[size]</span></code>. This is included for backwards
compatibility and may be removed in the future.</p>
<p>For convenience, classical registers can be assigned a text string
containing zeros and ones of the same length as the size of the
register. It is interpreted to assign each bit of the register to
corresponding value 0 or 1 in the string, where the least-significant
bit is on the right.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a register of 20 bits</span>
<span class="n">bit</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="n">bit_array</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Declare and assign a rgister of bits with decimal value of 15</span>
<span class="n">bit</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;00001111&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="integers">
<h3>Integers<a class="headerlink" href="#integers" title="Permalink to this headline">¶</a></h3>
<p>There are n-bit signed and unsigned integers. The statements <code class="docutils literal notranslate"><span class="pre">int[size]</span> <span class="pre">name;</span></code> and <code class="docutils literal notranslate"><span class="pre">uint[size]</span> <span class="pre">name;</span></code> declare
signed 1:n-1:0 and unsigned 0:n:0 integers of the given size. The sizes
are always explicitly part of the type; there is no implicit width for
classical types in OpenQASM. Because register indices are integers, they
can be cast from classical registers containing measurement outcomes and
may only be known at run time. An n-bit classical register containing
bits can also be reinterpreted as an integer, and these types can be
mutually cast to one another using the type name, e.g. <code class="docutils literal notranslate"><span class="pre">int[16](c)</span></code>. As noted, this
conversion will be done assuming little-endian bit ordering. The example
below demonstrates how to declare, assign and cast integer types amongst
one another.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a 32-bit unsigned integer</span>
<span class="n">uint</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">my_uint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Declare a 16 bit signed integer</span>
<span class="kt">int</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="n">my_int</span><span class="p">;</span><span class="w"></span>
<span class="n">my_int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">16</span><span class="p">](</span><span class="n">my_uint</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="floating-point-numbers">
<h3>Floating point numbers<a class="headerlink" href="#floating-point-numbers" title="Permalink to this headline">¶</a></h3>
<p>IEEE 754 floating point registers may be declared with <code class="docutils literal notranslate"><span class="pre">float[size]</span> <span class="pre">name;</span></code>, where <code class="docutils literal notranslate"><span class="pre">float[64]</span></code> would
indicate a standard double-precision float. Note that some hardware
vendors may not support manipulating these values at run-time.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a single-precision 32-bit float</span>
<span class="kt">float</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">my_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">π</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="fixed-point-angles">
<h3>Fixed-point angles<a class="headerlink" href="#fixed-point-angles" title="Permalink to this headline">¶</a></h3>
<p>Fixed-point angles are interpreted as 2π times a 0:0:n
fixed-point number. This represents angles in the interval
<span class="math notranslate nohighlight">\([0,2\pi)\)</span> up to an error <span class="math notranslate nohighlight">\(\epsilon\leq \pi/2^{n-1}\)</span> modulo
2π. The statement <code class="docutils literal notranslate"><span class="pre">angle[size]</span> <span class="pre">name;</span></code> declares an n-bit angle. OpenQASM3
introduces this specialized type because of the ubiquity of this angle
representation in phase estimation circuits and numerically controlled
oscillators found in hardware platform. Note that defining gate
parameters with <code class="docutils literal notranslate"><span class="pre">angle</span></code> types may be necessary for those parameters to be
compatible with run-time values on some platforms.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare an angle with 20 bits of precision and assign it a value of π/2</span>
<span class="n">angle</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="w"> </span><span class="n">my_angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">π</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">float_pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">π</span><span class="p">;</span><span class="w"></span>
<span class="c1">// equivalent to pi_by_2 up to rounding errors</span>
<span class="n">angle</span><span class="p">[</span><span class="mi">20</span><span class="p">](</span><span class="n">float_pi</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="complex-numbers">
<h3>Complex numbers<a class="headerlink" href="#complex-numbers" title="Permalink to this headline">¶</a></h3>
<p>Complex numbers may be declared as <code class="docutils literal notranslate"><span class="pre">complex[type[size]]</span> <span class="pre">name</span></code>, for a numeric OpenQASM classical type
<code class="docutils literal notranslate"><span class="pre">type</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">angle</span></code>) and a number of bits <code class="docutils literal notranslate"><span class="pre">size</span></code>. The real
and imaginary parts of the complex number are <code class="docutils literal notranslate"><span class="pre">type[size]</span></code> types. For instance, <code class="docutils literal notranslate"><span class="pre">complex[float[32]]</span> <span class="pre">c</span></code>
would declare a complex number with real and imaginary parts that are 32-bit floating point numbers. The
<code class="docutils literal notranslate"><span class="pre">im</span></code> keyword defines the imaginary number <span class="math notranslate nohighlight">\(sqrt(-1)\)</span>. <code class="docutils literal notranslate"><span class="pre">complex[type[size]]</span></code> types are initalized as
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">im</span></code>, where <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> must be of the same type as <code class="docutils literal notranslate"><span class="pre">type[size]</span></code>. <code class="docutils literal notranslate"><span class="pre">b</span></code> must occur to the
left of <code class="docutils literal notranslate"><span class="pre">im</span></code> and the two can only be seperated by spaces/tabs (or nothing at all).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>complex[float[64]] c;
c = 2.5 + 3.5im; // 2.5, 3.5 are resolved to be ``float[64]`` types
complex[float[64]] d = 2.0+sin(π) + 3.1*5.5 im;
complex[int[32]] f = 2 + 5 im; // 2, 5 are resolved to be ``int[32]`` types
</pre></div>
</div>
</section>
<section id="boolean-types">
<h3>Boolean types<a class="headerlink" href="#boolean-types" title="Permalink to this headline">¶</a></h3>
<p>There is a Boolean type <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">name;</span></code> that takes values <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. Qubit measurement results
can be converted from a classical <code class="docutils literal notranslate"><span class="pre">bit</span></code> type to a Boolean using <code class="docutils literal notranslate"><span class="pre">bool(c)</span></code>, where 1 will
be true and 0 will be false.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bit</span><span class="w"> </span><span class="n">my_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">my_bool</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Assign a cast bit to a boolean</span>
<span class="n">my_bool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bool</span><span class="p">(</span><span class="n">my_bit</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="const-values">
<h3>Const values<a class="headerlink" href="#const-values" title="Permalink to this headline">¶</a></h3>
<p>To support mathematical expressions, immutable constants of any classical type
may be declared using the type modifier <code class="docutils literal notranslate"><span class="pre">const</span></code>. On
declaration, they take their assigned value and cannot be redefined
within the same scope. These are constructed using an in-fix notation
and scientific calculator features such as scientific notation, real
arithmetic, logarithmic, trigonometric, and exponential functions
including <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>, <code class="docutils literal notranslate"><span class="pre">floor</span></code>, <code class="docutils literal notranslate"><span class="pre">ceiling</span></code>, <code class="docutils literal notranslate"><span class="pre">log</span></code>, <code class="docutils literal notranslate"><span class="pre">pow</span></code>, <code class="docutils literal notranslate"><span class="pre">div</span></code>, <code class="docutils literal notranslate"><span class="pre">mod</span></code> and the built-in constant π. The
statement <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">type</span> <span class="pre">name</span> <span class="pre">=</span> <span class="pre">expression;</span></code> defines a new constant. The expression on the right hand side
has a similar syntax as OpenQASM 2 parameter expressions; however,
previously defined constants can be referenced in later variable
declarations. <code class="docutils literal notranslate"><span class="pre">const`</span></code> values are compile-time constants, allowing the
compiler to do constant folding and other such optimizations. Scientific
calculator-like operations on run-time values require extern function
calls as described later and are not available by default. Real
constants can be cast to other types, just like other values.</p>
<p>A standard set of built-in constants which are included in the default
namespace are listed in table <a class="reference external" href="#tab:real-constants">1</a>. These constants
are all of type <code class="docutils literal notranslate"><span class="pre">float[64]</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a constant</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Scientific notation is supported</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="n">another_const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e12</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Constant expressions are supported</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="w"> </span><span class="n">pi_by_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">π</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Constants may be cast to real-time values</span>
<span class="kt">float</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">pi_by_2_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="mi">32</span><span class="p">](</span><span class="n">pi_by_2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<div class="docutils container" id="tab-real-constants">
<table class="docutils align-default" id="id2">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">[tab:real-constants] Built-in real constants in OpenQASM3 of type <code class="docutils literal notranslate"><span class="pre">float[64]</span></code>.</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 39%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Constant</p></td>
<td><p>Alphanumeric</p></td>
<td><p>Unicode</p></td>
<td><p>Approximate Base 10</p></td>
</tr>
<tr class="row-even"><td><p>Pi</p></td>
<td><p>pi</p></td>
<td><p>π</p></td>
<td><p>3.1415926535…</p></td>
</tr>
<tr class="row-odd"><td><p>Tau</p></td>
<td><p>tau</p></td>
<td><p>τ</p></td>
<td><p>6.283185…</p></td>
</tr>
<tr class="row-even"><td><p>Euler’s number</p></td>
<td><p>euler</p></td>
<td><p>ℇ</p></td>
<td><p>2.7182818284…</p></td>
</tr>
</tbody>
</table>
</div>
<p>Note that <cite>e</cite> is a valid identifier. <cite>e/E</cite> are also used in scientific notation where appropriate.</p>
</section>
</section>
<section id="types-related-to-timing">
<h2>Types related to timing<a class="headerlink" href="#types-related-to-timing" title="Permalink to this headline">¶</a></h2>
<section id="duration">
<h3>Duration<a class="headerlink" href="#duration" title="Permalink to this headline">¶</a></h3>
<p>We introduce a <code class="docutils literal notranslate"><span class="pre">duration</span></code> type to express timing.
Durations are positive numbers with a unit of time. <code class="docutils literal notranslate"><span class="pre">ns,</span> <span class="pre">μs,</span> <span class="pre">ms,</span> <span class="pre">s</span></code> are used for SI time
units. <code class="docutils literal notranslate"><span class="pre">dt</span></code> is a backend-dependent unit equivalent to one waveform sample on
the backend. <code class="docutils literal notranslate"><span class="pre">durationof()</span></code> is an intrinsic function used to reference the duration of a calibrated gate.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">duration</span><span class="w"> </span><span class="n">one_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="n">ms</span><span class="p">;</span><span class="w"></span>
<span class="n">duration</span><span class="w"> </span><span class="n">thousand_cycles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="n">dt</span><span class="p">;</span><span class="w"></span>
<span class="n">duration</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">durationof</span><span class="p">({</span><span class="n">x</span><span class="w"> </span><span class="n">$3</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">duration</span></code> is further discussed in <a class="reference internal" href="delays.html#duration-and-stretch"><span class="std std-ref">Duration and stretch types</span></a></p>
</section>
<section id="stretch">
<h3>Stretch<a class="headerlink" href="#stretch" title="Permalink to this headline">¶</a></h3>
<p>We further introduce a <code class="docutils literal notranslate"><span class="pre">stretch</span></code> type which is a sub-type of <code class="docutils literal notranslate"><span class="pre">duration</span></code>. <code class="docutils literal notranslate"><span class="pre">stretch</span></code> types
have variable non-negative duration that is permitted to grow as necessary
to satisfy constraints. Stretch variables are resolved at compile time
into target-appropriate durations that satisfy a user’s specified design
intent.</p>
<p><code class="docutils literal notranslate"><span class="pre">stretch</span></code> is further discussed in <a class="reference internal" href="delays.html#duration-and-stretch"><span class="std std-ref">Duration and stretch types</span></a></p>
</section>
</section>
<section id="aliasing">
<h2>Aliasing<a class="headerlink" href="#aliasing" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword allows quantum bits and registers to be referred to by
another name as long as the alias is in scope.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"></span>
<span class="c1">// myreg[0] refers to the qubit q[1]</span>
<span class="n">let</span><span class="w"> </span><span class="n">myreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="register-concatenation-and-slicing">
<h2>Register concatenation and slicing<a class="headerlink" href="#register-concatenation-and-slicing" title="Permalink to this headline">¶</a></h2>
<p>Two or more registers of the same type (i.e. classical or quantum) can
be concatenated to form a register of the same type whose size is the
sum of the sizes of the individual registers. The concatenated register
is a reference to the bits or qubits of the original registers. The
statement <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">++</span> <span class="pre">b</span></code> denotes the concatenation of registers <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. A register cannot
be concatenated with any part of itself.</p>
<p>Classical and quantum registers can be indexed in a way that selects a
subset of (qu)bits, i.e. by an index set. A register so indexed is
interpreted as a register of the same type but with a different size.
The register slice is a reference to the original register. A register
cannot be indexed by an empty index set.</p>
<p>An index set can be specified by a single integer (signed or unsigned), a
comma-separated list of unsigned integers <code class="docutils literal notranslate"><span class="pre">a,b,c,…</span></code>, or a range. A
range is written as <code class="docutils literal notranslate"><span class="pre">a:b</span></code> or <code class="docutils literal notranslate"><span class="pre">a:c:b</span></code> where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> are integers (signed or unsigned).
The range corresponds to the set <span class="math notranslate nohighlight">\(\{a, a+c, a+2c, \dots, a+mc\}\)</span>
where <span class="math notranslate nohighlight">\(m\)</span> is the largest integer such that <span class="math notranslate nohighlight">\(a+mc\leq b\)</span> if
<span class="math notranslate nohighlight">\(c&gt;0\)</span> and <span class="math notranslate nohighlight">\(a+mc\geq b\)</span> if <span class="math notranslate nohighlight">\(c&lt;0\)</span>. If <span class="math notranslate nohighlight">\(a=b\)</span> then
the range corresponds to <span class="math notranslate nohighlight">\(\{a\}\)</span>. Otherwise, the range is the
empty set. If <span class="math notranslate nohighlight">\(c\)</span> is not given, it is assumed to be one, and
<span class="math notranslate nohighlight">\(c\)</span> cannot be zero. Note the index sets can be defined by
variables whose values may only be known at run time.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">qubit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="n">one</span><span class="p">;</span><span class="w"></span>
<span class="n">qubit</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="n">two</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Aliased register of twelve qubits</span>
<span class="n">let</span><span class="w"> </span><span class="n">concatenated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">two</span><span class="p">;</span><span class="w"></span>
<span class="c1">// First qubit in aliased qubit array</span>
<span class="n">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concatenated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="c1">// Last qubit in aliased qubit array</span>
<span class="n">let</span><span class="w"> </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concatenated</span><span class="p">[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="c1">// Qubits zero, three and five</span>
<span class="n">let</span><span class="w"> </span><span class="n">qubit_selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">two</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="c1">// First six qubits in aliased qubit array</span>
<span class="n">let</span><span class="w"> </span><span class="n">sliced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concatenated</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="c1">// Every second qubit</span>
<span class="n">let</span><span class="w"> </span><span class="n">every_second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concatenated</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">12</span><span class="p">];</span><span class="w"></span>
<span class="c1">// Using negative ranges to take the last 3 elements</span>
<span class="n">let</span><span class="w"> </span><span class="n">last_three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">two</span><span class="p">[</span><span class="mi">-4</span><span class="o">:</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="c1">// Concatenate two alias in another one</span>
<span class="n">let</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sliced</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">last_three</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">OpenQASM Live Specification</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="comments.html">Comments</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#version-string">Version string</a></li>
<li class="toctree-l2"><a class="reference internal" href="comments.html#included-files">Included files</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Types and Casting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generalities">Generalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-types">Quantum types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classical-types">Classical types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types-related-to-timing">Types related to timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aliasing">Aliasing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-concatenation-and-slicing">Register concatenation and slicing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gates.html">Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="insts.html">Built-in quantum instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="classical.html">Classical instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="subroutines.html">Subroutines</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html">Directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="directives.html#input-output">Input/output</a></li>
<li class="toctree-l2"><a class="reference internal" href="delays.html">Circuit timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pulses.html">Pulse-level descriptions of gates and measurement</a></li>
<li class="toctree-l2"><a class="reference internal" href="openpulse.html">OpenPulse Grammar</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../grammar/index.html">OpenQasm 3.0 Grammar</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Language</a><ul>
      <li>Previous: <a href="comments.html" title="previous chapter">Comments</a></li>
      <li>Next: <a href="gates.html" title="next chapter">Gates</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2020, Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/language/types.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>